global:
  security:
    allowInsecureImages: true

mysql:
  enabled: true
  fullnameOverride: "mysql"
  service:
    type: NodePort
    nodePorts:
      mysql: 30006
  image:
    registry: docker.io
    repository: bitnamilegacy/mysql
    tag: "8.0.37-debian-12-r2"
  auth:
    rootPassword: "root"
    createDatabase: true
    database: "keycloak"
    username: "keycloak"
    password: "password123"
  persistence:
    enabled: true
    size: 8Gi
kafka:
  enabled: true
  fullnameOverride: testing-app-kafka
  image:
    registry: docker.io
    repository: bitnamilegacy/kafka
    tag: "3.9.0-debian-12-r0"
  kraft:
    enabled: true
  controller:
    replicaCount: 3
    controllerOnly: true
  broker:
    replicaCount: 3
  persistence:
    enabled: true
    size: 8Gi
  podSecurityContext:
    enabled: true
    fsGroup: 1001
  containerSecurityContext:
    enabled: true
    runAsUser: 1001
  listeners:
    client:
      protocol: PLAINTEXT
    interbroker:
      protocol: PLAINTEXT
    controller:
      protocol: PLAINTEXT
    external:
      protocol: PLAINTEXT
  extraEnvVars:
    - name: KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE
      value: "true"
    - name: KAFKA_CFG_OFFSETS_TOPIC_REPLICATION_FACTOR
      value: "3"
    - name: KAFKA_CFG_TRANSACTION_STATE_LOG_REPLICATION_FACTOR
      value: "3"
    - name: KAFKA_CFG_TRANSACTION_STATE_LOG_MIN_ISR
      value: "2"
    - name: KAFKA_CFG_DEFAULT_REPLICATION_FACTOR
      value: "3"
    - name: KAFKA_CFG_MIN_INSYNC_REPLICAS
      value: "2"
  externalAccess:
    enabled: true
    autoDiscovery:
      enabled: false
    broker:
      service:
        type: NodePort
        domain: localhost
        ports:
          external: 9094
        nodePorts:
          - 30001
          - 30002
          - 30003

kafka-ui:
  enabled: true
  envs:
    config:
      KAFKA_CLUSTERS_0_NAME: "local"
      KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS: "testing-app-kafka:9092"
      DYNAMIC_CONFIG_ENABLED: "true"
      SERVER_SERVLET_CONTEXT_PATH: "/kafka"
  ingress:
    enabled: true
    ingressClassName: "nginx"
    host: "localhost"
    path: "/kafka"
    pathType: "Prefix"

elasticsearch:
  enabled: true
  # architecture: standalone
  # replicaCount: 1  
  master:
    replicaCount: 1
  data:
    replicaCount: 1
  # Forțează crearea serviciului principal chiar și fără coordinating nodes
  coordinating:
    replicaCount: 0
    service:
      type: ClusterIP
  ingest:
    replicaCount: 0
  image:
    registry: docker.io
    repository: bitnamilegacy/elasticsearch
    tag: 9.1.2-debian-12-r0
    digest: ""
    pullPolicy: IfNotPresent
 ## Adaugă această secțiune pentru a suprascrie imaginea care dă eroare
  sysctlImage:
    registry: docker.io
    repository: bitnamilegacy/os-shell
    tag: 12-debian-12-r50 # Sau o versiune existentă în legacy
    pullPolicy: IfNotPresent

  # Dacă eroarea persistă la permisiunile volumelor:
  volumePermissions:
    enabled: true
    image:
      registry: docker.io
      repository: bitnamilegacy/os-shell
      tag: 12-debian-12-r50    
  security:
    enabled: true
    elasticPassword: "paassw0rd"
    tls:
      restEncryption: true
      autoGenerated: true
  persistence:
    enabled: true
    size: 10Gi
  resources:
    requests:
      cpu: 200m
      memory: 1Gi
    limits:
      cpu: 500m
      memory: 2Gi

kibana:
  enabled: true
  image:
    registry: docker.io
    repository: bitnamilegacy/kibana
    tag: 9.1.2-debian-12-r0
  elasticsearch:
    hosts:
      - "resurse-app-elasticsearch"
    port: 9200
    security:
      auth:
        enabled: true
        kibanaPassword: "paassw0rd"
        createSystemUser: true
        elasticsearchPasswordSecret: "resurse-app-elasticsearch"
      tls:
        enabled: true
        verificationMode: "none"
  extraEnvVars:
    - name: NODE_OPTIONS
      value: "--max-old-space-size=2048" # Alocă 2GB pentru procesul Node.js
    # Adaugă și variabila SAMESITE pe care o aveai în cel vechi
    - name: KIBANA_SERVER_SAMESITECOOKIES
      value: "None"
  configuration:
    server:
      basePath: "/kibana"
      publicBaseUrl: "http://localhost/kibana"
      rewriteBasePath: true
  readinessProbe:
    enabled: true
    initialDelaySeconds: 180 # Oferă-i 2 minute să pornească
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 6
    httpGet:
      path: "/kibana/status"
      port: http
  resources:
    limits:
      cpu: 500m
      memory: 2Gi
    requests:
      cpu: 200m
      memory: 1Gi

  ingress:
    enabled: true
    ingressClassName: "nginx"
    hostname: "localhost"
    path: "/kibana"
    pathType: "Prefix"
    annotations:
      # Aceasta forțează Nginx să paseze prefixul corect către aplicație
      nginx.ingress.kubernetes.io/x-forwarded-prefix: "/kibana"

logstash:
  enabled: true
  image:
    registry: docker.io
    repository: bitnamilegacy/logstash
    tag: 9.1.2-debian-12-r0
  extraEnvVars:
    - name: ELASTICSEARCH_HOST
      value: "resurse-app-elasticsearch"
    - name: ELASTICSEARCH_PORT
      value: "9200"
    - name: ES_PASSWORD
      valueFrom:
        secretKeyRef:
          name: resurse-app-elasticsearch
          key: elasticsearch-password # cheia găsită la pasul 1
  output: |-
    elasticsearch {
      hosts => ["https://${ELASTICSEARCH_HOST}:${ELASTICSEARCH_PORT}"]
      index => "logstash-%{+YYYY.MM.dd}"
      user => "elastic"
      password => "${ES_PASSWORD}"
      ilm_enabled => false
      ssl_enabled => true
      ssl_verification_mode => "none"
      # ADAUGĂ ASTA PENTRU A IGNORA EROAREA DE VERSIUNE/LICENȚĂ
      healthcheck_path => "/" 
    }
  input: |-
    tcp {
      port => 5044
      codec => json_lines  # Folosește json_lines în loc de json pentru Logback
    }
  containerPorts: 
    - name: logstash-tcp
      containerPort: 5044
      protocol: TCP

  service:
    type: NodePort
    ports:
      - name: logstash-tcp
        port: 5044
        targetPort: 5044
        protocol: TCP
        nodePort: 30544
# testing-app-deps:
keycloak:
  enabled: true
  image: 
    registry: public.ecr.aws
    repository: bitnami/keycloak
    tag: 26.1.3
    pullPolicy: IfNotPresent
    debug: false
  auth:
    adminUser: "admin"
    adminPassword: "StrongPassword123!" # Evită "admin" ca parolă, unele imagini o resping
  production: false
  
  externalDatabase:
    host: "mysql"
    port: 3306
    user: "keycloak"
    password: "password123"
    database: "keycloak"

  extraEnvVars:
    - name: KEYCLOAK_EXTRA_ARGS
      value: "--import-realm"

  realmImport:
    enabled: true
    configMapName: "app-config"
    file: "files/keycloak/realm-export.json"
    key: "realm-export.json"


  # Corecție probe: Keycloak 26 folosește /health/live sau /health/ready
  readinessProbe:
    enabled: false
  livenessProbe:
    enabled: false
  postgresql:
    enabled: false

  extraVolumes:
    - name: realm-data
      configMap:
        name: app-config
        items:
          - key: realm-export.json
            path: realm-export.json

  # 3. Montează fișierul în folderul pe care îl scanează Bitnami Keycloak
  extraVolumeMounts:
    - name: realm-data
      mountPath: /opt/bitnami/keycloak/data/import
      readOnly: true
