global:
  security:
    allowInsecureImages: true

mysql:
  enabled: true
  image:
    registry: docker.io
    repository: bitnamilegacy/mysql
    tag: "8.0.37-debian-12-r2"
  auth:
    rootPassword: "root"
    database: "my_database"
  persistence:
    enabled: true
    size: 8Gi
  # --- ADAUGA DE AICI ---
  primary:
    extraVolumes:
      - name: mysql-init-scripts
        configMap:
          name: app-config # Numele actualizat din metadata ta
          items:
            - key: keycloak-db.sql
              path: init-db.sql # MySQL va executa acest fișier la pornire
    extraVolumeMounts:
      - name: mysql-init-scripts
        mountPath: /docker-entrypoint-initdb.d

kafka:
  enabled: true
  fullnameOverride: testing-app-kafka
  image:
    registry: docker.io
    repository: bitnamilegacy/kafka
    tag: "3.9.0-debian-12-r0"
  kraft:
    enabled: true
  controller:
    replicaCount: 3
    controllerOnly: true
  broker:
    replicaCount: 3
  persistence:
    enabled: true
    size: 8Gi
  podSecurityContext:
    enabled: true
    fsGroup: 1001
  containerSecurityContext:
    enabled: true
    runAsUser: 1001
  listeners:
    client:
      protocol: PLAINTEXT
    interbroker:
      protocol: PLAINTEXT
    controller:
      protocol: PLAINTEXT
    external:
      protocol: PLAINTEXT
  extraEnvVars:
    - name: KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE
      value: "true"
    - name: KAFKA_CFG_OFFSETS_TOPIC_REPLICATION_FACTOR
      value: "3"
    - name: KAFKA_CFG_TRANSACTION_STATE_LOG_REPLICATION_FACTOR
      value: "3"
    - name: KAFKA_CFG_TRANSACTION_STATE_LOG_MIN_ISR
      value: "2"
    - name: KAFKA_CFG_DEFAULT_REPLICATION_FACTOR
      value: "3"
    - name: KAFKA_CFG_MIN_INSYNC_REPLICAS
      value: "2"
  externalAccess:
    enabled: true
    autoDiscovery:
      enabled: false
    broker:
      service:
        type: NodePort
        domain: localhost
        ports:
          external: 9094
        nodePorts:
          - 30001
          - 30002
          - 30003

kafka-ui:
  enabled: true
  envs:
    config:
      KAFKA_CLUSTERS_0_NAME: "local"
      KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS: "testing-app-kafka:9092"
      DYNAMIC_CONFIG_ENABLED: "true"
      SERVER_SERVLET_CONTEXT_PATH: "/kafka"
  ingress:
    enabled: true
    ingressClassName: "nginx"
    host: "localhost"
    path: "/kafka"
    pathType: "Prefix"

elasticsearch:
  enabled: true
  # architecture: standalone
  # replicaCount: 1  
  master:
    replicaCount: 1
  data:
    replicaCount: 1
  # Forțează crearea serviciului principal chiar și fără coordinating nodes
  coordinating:
    replicaCount: 0
    service:
      type: ClusterIP
  ingest:
    replicaCount: 0
  image:
    registry: docker.io
    repository: bitnamilegacy/elasticsearch
    tag: 9.1.2-debian-12-r0
    digest: ""
    pullPolicy: IfNotPresent
 ## Adaugă această secțiune pentru a suprascrie imaginea care dă eroare
  sysctlImage:
    registry: docker.io
    repository: bitnamilegacy/os-shell
    tag: 12-debian-12-r50 # Sau o versiune existentă în legacy
    pullPolicy: IfNotPresent

  # Dacă eroarea persistă la permisiunile volumelor:
  volumePermissions:
    enabled: true
    image:
      registry: docker.io
      repository: bitnamilegacy/os-shell
      tag: 12-debian-12-r50    
  security:
    enabled: true
    elasticPassword: "paassw0rd"
    tls:
      restEncryption: true
      autoGenerated: true
  persistence:
    enabled: true
    size: 10Gi
  resources:
    requests:
      cpu: 200m
      memory: 1Gi
    limits:
      cpu: 500m
      memory: 2Gi

kibana:
  enabled: true
  image:
    registry: docker.io
    repository: bitnamilegacy/kibana
    tag: 9.1.2-debian-12-r0
  elasticsearch:
    hosts:
      - "my-app-elasticsearch"
    port: 9200
    security:
      auth:
        enabled: true
        kibanaPassword: "paassw0rd"
        createSystemUser: true
        elasticsearchPasswordSecret: "my-app-elasticsearch"
      tls:
        enabled: true
        verificationMode: "none"
  extraEnvVars:
    - name: NODE_OPTIONS
      value: "--max-old-space-size=2048" # Alocă 2GB pentru procesul Node.js
    - name: KIBANA_SERVER_BASEPATH
      value: "/kibana"
    - name: SERVER_BASEPATH # Adăugat ca backup pentru compatibilitate
      value: "/kibana"
    - name: KIBANA_SERVER_REWRITEBASEPATH
      value: "true"
    # Adaugă și variabila SAMESITE pe care o aveai în cel vechi
    - name: KIBANA_SERVER_SAMESITECOOKIES
      value: "None"
  readinessProbe:
    enabled: true
    initialDelaySeconds: 180 # Oferă-i 2 minute să pornească
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 6
    httpGet:
      path: "/kibana/status"
      port: http
  resources:
    limits:
      cpu: 500m
      memory: 2Gi
    requests:
      cpu: 200m
      memory: 1Gi

  ingress:
    enabled: true
    ingressClassName: "nginx"
    host: "kibana.local"
    path: "/"
    pathType: "ImplementationSpecific" # Schimbă de la Prefix pentru a fi mai flexibil
    annotations:
      # Aceasta forțează Nginx să paseze prefixul corect către aplicație
      nginx.ingress.kubernetes.io/x-forwarded-prefix: "/kibana"

logstash:
  enabled: true
  image:
    registry: docker.io
    repository: bitnamilegacy/logstash
    tag: 9.1.2-debian-12-r0
  extraEnvVars:
    - name: ELASTICSEARCH_HOST
      value: "my-app-elasticsearch"
    - name: ELASTICSEARCH_PORT
      value: "9200"
    - name: ES_PASSWORD
      valueFrom:
        secretKeyRef:
          name: my-app-elasticsearch
          key: elasticsearch-password # cheia găsită la pasul 1
  output: |-
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOST}:${ELASTICSEARCH_PORT}"]
      index => "logstash-%{+YYYY.MM.dd}"
      user => "elastic"
      password => "${ES_PASSWORD}"
      ilm_enabled => false
      ssl_verification_mode => "none"
      # ADAUGĂ ASTA PENTRU A IGNORA EROAREA DE VERSIUNE/LICENȚĂ
      healthcheck_path => "/" 
    }
  input: |-
    tcp {
      port => 3100
      codec => json_lines  # Folosește json_lines în loc de json pentru Logback
    }
  containerPorts: 
    - name: logstash-tcp
      containerPort: 3100
      protocol: TCP

  service:
    ports:
      - name: logstash-tcp
        port: 3100
        targetPort: 3100
        protocol: TCP

zipkin:
  enabled: true
  image: 
    registry: public.ecr.aws
    repository: bitnami/zipkin
    tag: 3.5.1-debian-12-r5
    pullPolicy: IfNotPresent
    debug: false

  resources:
      limits:
        cpu: 500m
        memory: 1024Mi
      requests:
        cpu: 250m
        memory: 512Mi

    ## Tipul de stocare (Default: memorie, nu persistă la restart)
    ## Opțiuni: mem, mysql, cassandra, elasticsearch
  storageType: mem

  ## Configurarea Serviciului (pentru acces din exterior)
  service:
    type: ClusterIP
    ports:
      http: 9411

  ## Activarea Ingress-ului (pentru acces prin domeniu)
  # ingress:
  #   enabled: true
  #   hostname: zipkin.local
  #   annotations:
  #     kubernetes.io/ingress.class: nginx

# alertmanager:
#   enabled: false
#   # image:
#   #   registry: docker.io
#   #   repository: bitnamilegacy/alertmanager
#   #   tag: 0.28.1-debian-12-r15

# # Blocul pentru Cassandra (tot la același nivel, dacă vrei să o dezactivezi)
# cassandra:
#   enabled: false

prometheus:
  enabled: true
  image:
    registry: public.ecr.aws
    repository: bitnamilegacy/prometheus
    tag: 3.5.0-debian-12-r3
    pullPolicy: Always
  debug: false
  # auth:
  #   adminUser: "admin"
  #   adminPassword: "admin"
  production: false
  # proxy: none
  
  server:
    replicaCount: 1
    configMapName: app-config
    configMapKey: prometheus.yml
    extraArgs:
      - "--config.file=/opt/bitnami/prometheus/conf/prometheus.yml"
  persistence:
    enabled: true
    existingClaim: prometheus-pvc
  extraVolumes:
    - name: prometheus-config-volume
      configMap:
        name: app-config
  extraVolumeMounts:
    - name: prometheus-config-volume
      mountPath: /opt/bitnami/prometheus/conf/prometheus.yml
      subPath: prometheus.yml
  service:
    type: ClusterIP
    ports:
      http: 9090

grafana:
  enabled: true
  # Imaginea (folosim Public ECR pentru stabilitate)
  image:
    registry: public.ecr.aws
    repository: bitnami/grafana
    tag: 12.1.1-debian-12-r1

  # Autentificare
  admin:
    user: admin
    password: "parola_ta_secreta"

  # Conectare automată la Prometheus-ul tău
  datasources:
    secretName: "" # Putem defini sursele direct în YAML
    config:
      datasources:
        - name: Prometheus
          type: prometheus
          url: http://my-app-prometheus-server:9090 # Numele serviciului de Prometheus creat anterior
          access: proxy
          isDefault: true

  # Persistență pentru dashboard-uri și setări
  persistence:
    enabled: true
    size: 5Gi
    # existingClaim: "grafana-pvc" # Dacă ai deja un PVC creat

  # Ingress pentru a accesa Grafana din browser
  ingress:
    enabled: true
    hostname: grafana.local
    path: /
    annotations:
      kubernetes.io/ingress.class: nginx


# testing-app-deps:
keycloak:
  enabled: true
  dbHost: "postgresql" 
  image: 
    registry: public.ecr.aws
    repository: bitnami/keycloak
    tag: 26.1.3
    pullPolicy: IfNotPresent
    debug: false
  # auth:
  #   adminUser: "admin"
  #   adminPassword: "admin"
  production: false
  proxy: none
  auth:
    adminUser: "admin"
    adminPassword: "StrongPassword123!" # Evită "admin" ca parolă, unele imagini o resping
  production: false
  proxy: none
  
  extraEnvVars:
    - name: KEYCLOAK_ADMIN
      value: "admin"
    - name: KEYCLOAK_ADMIN_PASSWORD
      value: "StrongPassword123!"
    - name: KC_BOOTSTRAP_ADMIN_USERNAME
      value: "admin"
    - name: KC_BOOTSTRAP_ADMIN_PASSWORD
      value: "StrongPassword123!"
    - name: KC_DB_USERNAME
      value: "keycloak"
    - name: KC_DB_PASSWORD
      value: "password123"
    - name: KC_DB_URL
      value: "jdbc:postgresql://postgresql:5432/keycloak"
    - name: KEYCLOAK_EXTRA_ARGS
      value: "--import-realm"


  # Corecție probe: Keycloak 26 folosește /health/live sau /health/ready
  readinessProbe:
    enabled: false
  livenessProbe:
    enabled: false
  postgresql:
    fullnameOverride: "postgresql"
    enabled: true
    image:
      registry: public.ecr.aws
      repository: bitnami/postgresql
      tag: 17.6.0
      debug: false
      pullPolicy: Always
    auth:
      database: "keycloak"
      username: "keycloak"
      password: "password123"
      postgresPassword: "password123"

  extraVolumes:
    - name: realm-data
      configMap:
        name: app-config
        items:
          - key: realm-export.json
            path: realm-export.json

  # 3. Montează fișierul în folderul pe care îl scanează Bitnami Keycloak
  extraVolumeMounts:
    - name: realm-data
      mountPath: /opt/bitnami/keycloak/data/import
      readOnly: true